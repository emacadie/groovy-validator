import info.shelfunit.properties.annotations.ImmutableValidator as ImmutableValidator
import info.shelfunit.properties.annotations.StringAnnotation as StringAnnotation

@groovy.transform.ToString(includeNames = true)
@groovy.transform.Immutable
@info.shelfunit.properties.annotations.AstImmutableConstructor
final public class ImmutableRegEx implements groovy.lang.GroovyObject extends java.lang.Object { 

    final private java.lang.String groovyString 
    final private java.lang.String yearWithDay 
    final private java.lang.String password 
    private int $hash$code 
    private static org.codehaus.groovy.reflection.ClassInfo $staticClassInfo 
    public static transient boolean __$stMC 
    private transient groovy.lang.MetaClass metaClass 
    public static long __timeStamp 
    public static long __timeStamp__239_neverHappen1410066528296 

    public ImmutableRegEx(java.util.HashMap args) {
        metaClass = /*BytecodeExpression*/
        if ( args .groovyString == null) {
            if (null != null) {
                this .groovyString = null
            }
        } else {
            this .groovyString = args .groovyString
        }
        if ( args .yearWithDay == null) {
            if (null != null) {
                this .yearWithDay = null
            }
        } else {
            this .yearWithDay = args .yearWithDay
        }
        if ( args .password == null) {
            if (null != null) {
                this .password = null
            }
        } else {
            this .password = args .password
        }
        org.codehaus.groovy.transform.ImmutableASTTransformation.checkPropNames(this, args)
        if ( args == null) {
            args = [:]
        }
    }

    public ImmutableRegEx() {
        this ([:])
    }

    public ImmutableRegEx(java.lang.String groovyString, java.lang.String yearWithDay, java.lang.String password) {
        this (((['groovyString': groovyString , 'yearWithDay': yearWithDay , 'password': password ]) as java.util.HashMap))
    }

    public ImmutableRegEx(java.util.LinkedHashMap argMap, boolean validation, boolean throwException) {
        this (ImmutableRegEx.createValidatingConstructor(argMap, validation, throwException))
    }

    public ImmutableRegEx(java.util.LinkedHashMap argMap, boolean validation) {
        this ((( argMap ) as java.util.LinkedHashMap), (( validation ) as boolean), ((false) as boolean))
    }

    public java.lang.String toString() {
        java.lang.Object _result = new java.lang.StringBuilder()
        java.lang.Object $toStringFirst = true
        _result.append('ImmutableRegEx(')
        if ( $toStringFirst ) {
            $toStringFirst = false
        } else {
            _result.append(', ')
        }
        _result.append('groovyString:')
        if (org.codehaus.groovy.runtime.InvokerHelper.getProperty(this, 'groovyString').is(this)) {
            _result.append('(this)')
        } else {
            _result.append(org.codehaus.groovy.runtime.InvokerHelper.toStringorg.codehaus.groovy.runtime.InvokerHelper.getProperty(this, 'groovyString'))
        }
        if ( $toStringFirst ) {
            $toStringFirst = false
        } else {
            _result.append(', ')
        }
        _result.append('yearWithDay:')
        if (org.codehaus.groovy.runtime.InvokerHelper.getProperty(this, 'yearWithDay').is(this)) {
            _result.append('(this)')
        } else {
            _result.append(org.codehaus.groovy.runtime.InvokerHelper.toStringorg.codehaus.groovy.runtime.InvokerHelper.getProperty(this, 'yearWithDay'))
        }
        if ( $toStringFirst ) {
            $toStringFirst = false
        } else {
            _result.append(', ')
        }
        _result.append('password:')
        if (org.codehaus.groovy.runtime.InvokerHelper.getProperty(this, 'password').is(this)) {
            _result.append('(this)')
        } else {
            _result.append(org.codehaus.groovy.runtime.InvokerHelper.toStringorg.codehaus.groovy.runtime.InvokerHelper.getProperty(this, 'password'))
        }
        _result.append(')')
        return _result.toString()
    }

    public int hashCode() {
        if ( $hash$code == 0) {
            java.lang.Object _result = org.codehaus.groovy.util.HashCodeHelper.initHash()
            if (!(org.codehaus.groovy.runtime.InvokerHelper.getProperty(this, 'groovyString').is(this))) {
                _result = org.codehaus.groovy.util.HashCodeHelper.updateHash(_result, org.codehaus.groovy.runtime.InvokerHelper.getProperty(this, 'groovyString'))
            }
            if (!(org.codehaus.groovy.runtime.InvokerHelper.getProperty(this, 'yearWithDay').is(this))) {
                _result = org.codehaus.groovy.util.HashCodeHelper.updateHash(_result, org.codehaus.groovy.runtime.InvokerHelper.getProperty(this, 'yearWithDay'))
            }
            if (!(org.codehaus.groovy.runtime.InvokerHelper.getProperty(this, 'password').is(this))) {
                _result = org.codehaus.groovy.util.HashCodeHelper.updateHash(_result, org.codehaus.groovy.runtime.InvokerHelper.getProperty(this, 'password'))
            }
            $hash$code = _result 
        }
        return $hash$code 
    }

    public boolean equals(java.lang.Object other) {
        if ( other == null) {
            return false
        }
        if (this.is(other)) {
            return true
        }
        if (!(ImmutableRegEx == other.getClass())) {
            return false
        }
        java.lang.Object otherTyped = (( other ) as ImmutableRegEx)
        if (!(this.getGroovyString().is(otherTyped.getGroovyString()))) {
            if (this.getGroovyString().is(this) && !(otherTyped.getGroovyString().is(otherTyped)) || !(this.getGroovyString().is(this)) && otherTyped.getGroovyString().is(otherTyped)) {
                return false
            } else {
                if (!(this.getGroovyString().is(this) && otherTyped.getGroovyString().is(otherTyped))) {
                    if (!(this.getGroovyString() == otherTyped.getGroovyString())) {
                        return false
                    }
                }
            }
        }
        if (!(this.getYearWithDay().is(otherTyped.getYearWithDay()))) {
            if (this.getYearWithDay().is(this) && !(otherTyped.getYearWithDay().is(otherTyped)) || !(this.getYearWithDay().is(this)) && otherTyped.getYearWithDay().is(otherTyped)) {
                return false
            } else {
                if (!(this.getYearWithDay().is(this) && otherTyped.getYearWithDay().is(otherTyped))) {
                    if (!(this.getYearWithDay() == otherTyped.getYearWithDay())) {
                        return false
                    }
                }
            }
        }
        if (!(this.getPassword().is(otherTyped.getPassword()))) {
            if (this.getPassword().is(this) && !(otherTyped.getPassword().is(otherTyped)) || !(this.getPassword().is(this)) && otherTyped.getPassword().is(otherTyped)) {
                return false
            } else {
                if (!(this.getPassword().is(this) && otherTyped.getPassword().is(otherTyped))) {
                    if (!(this.getPassword() == otherTyped.getPassword())) {
                        return false
                    }
                }
            }
        }
        return true
    }

    public java.lang.Object this$dist$invoke$1(java.lang.String name, java.lang.Object args) {
        return this."$name"(* args )
    }

    public void this$dist$set$1(java.lang.String name, java.lang.Object value) {
        this ."$name" = value 
    }

    public java.lang.Object this$dist$get$1(java.lang.String name) {
        return this ."$name"
    }

    public static java.lang.Object createValidatingConstructor(java.util.HashMap argMap, boolean validation, boolean throwException) {
        if (!( validation )) {
            return argMap 
        } else {
            java.util.HashMap newMap = [:]
            java.lang.Object val = 
            java.lang.Object theMatch = 
            java.lang.Object exceptionStringList = []
            newMap [ 'groovyString'] = argMap [ 'groovyString'].call( newMap [ 'yearWithDay'] = argMap [ 'yearWithDay'].call( newMap [ 'password'] = argMap [ 'password']))
            if ( throwException && exceptionStringList.size() > 0) {
                java.lang.Object exMessage = exceptionStringList.join(java.lang.System.lineSeparator())
                throw new java.lang.Exception('Groovy validation exception: ' + java.lang.System.lineSeparator() + exMessage )
            }
            return newMap 
        }
    }

    protected groovy.lang.MetaClass $getStaticMetaClass() {
    }

    public groovy.lang.MetaClass getMetaClass() {
    }

    public void setMetaClass(groovy.lang.MetaClass mc) {
    }

    public java.lang.Object invokeMethod(java.lang.String method, java.lang.Object arguments) {
    }

    public java.lang.Object getProperty(java.lang.String property) {
    }

    public void setProperty(java.lang.String property, java.lang.Object value) {
    }

    public static void __$swapInit() {
    }

    static { 
        __timeStamp__239_neverHappen1410066528296 = 0
        __timeStamp = 1410066528296
    }

    final public java.lang.String getGroovyString() {
        return groovyString 
    }

    final public java.lang.String getYearWithDay() {
        return yearWithDay 
    }

    final public java.lang.String getPassword() {
        return password 
    }

    public void super$1$wait() {
    }

    public java.lang.String super$1$toString() {
    }

    public void super$1$wait(long param0) {
    }

    public void super$1$wait(long param0, int param1) {
    }

    public void super$1$notify() {
    }

    public void super$1$notifyAll() {
    }

    public java.lang.Class<java.lang.Object extends java.lang.Object> super$1$getClass() {
    }

    public java.lang.Object super$1$clone() {
    }

    public boolean super$1$equals(java.lang.Object param0) {
    }

    public int super$1$hashCode() {
    }

    public void super$1$finalize() {
    }

}

